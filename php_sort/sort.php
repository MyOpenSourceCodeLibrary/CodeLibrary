<?php
class sort{
	
	/*
	*排序算法
	*1、insert，插入排序
	*2、chance，选择排序
	*3、bubble，冒泡排序
	*4、quick ，快速排序
	*$arr为传入的数组，假定该数组已经进行了键的初始化


	1>>插入排序算法
	每次将一个待排序的数据元素插入到前面已经排好序的数列中，使数列依然有序，知道待排序数据元素全部插入完为止。
	J=1(49) [49] 38 65 97 76 13 27 49
	J=2(38) [38 49] 65 97 76 13 27 49
	J=3(65) [38 49 65] 97 76 13 27 49
	J=4(97) [38 49 65 97] 76 13 27 49
	J=5(76) [38 49 65 76 97] 13 27 49
	J=6(13) [13 38 49 65 76 97] 27 49
	J=7(27) [13 27 38 49 65 76 97] 49
	J=8(49) [13 27 38 49 49 65 76 97]
	如果目标是把n个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况。
	最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需(n-1)次即可。
	最坏情况就是，序列是降序排列，那么此时需要进行的比较共有n(n-1)/2次。
	插入排序的赋值操作是比较操作的次数加上 (n-1)次。平均来说插入排序算法的时间复杂度为O(n^2)。
	因而，插入排序不适合对于数据量比较大的排序应用。
	但是，如果需要排序的数据量很小，例如，量级小于千，那么插入排序还是一个不错的选择。


	2>>选择排序
	思想：每一趟从待排序的数据元素中选出最小（或最大）的一个元素，顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完。
	示例：
	[初始关键字] [49 38 65 97 76 13 27 49]
	第一趟排序后 13 ［38 65 97 76 49 27 49]
	第二趟排序后 13 27 ［65 97 76 49 38 49]
	第三趟排序后 13 27 38 [97 76 49 65 49]
	第四趟排序后 13 27 38 49 [49 97 65 76]
	第五趟排序后 13 27 38 49 49 [97 97 76]
	第六趟排序后 13 27 38 49 49 76 [76 97]
	第七趟排序后 13 27 38 49 49 76 76 [ 97]
	最后排序结果 13 27 38 49 49 76 76 97
	时间复杂度：
	时间复杂度为o(n2),不稳定排序，适合规模比较小的


	3>>冒泡排序
	两两比较待排序数据元素的大小，发现两个数据元素的次序相反时即进行交换，直到没有反序的数据元素为止。
	示例：
	49 13 13 13 13 13 13 13 
	38 49 27 27 27 27 27 27
	65 38 49 38 38 38 38 38
	97 65 38 49 49 49 49 49
	76 97 65 49 49 49 49 49
	13 76 97 65 65 65 65 65
	27 27 76 97 76 76 76 76
	49 49 49 76 97 97 97 97
	时间复杂度：
	该算法的时间复杂度为O(n2)。
	但是，当原始关键字序列已有序时，只进行一趟比较就结束，此时时间复杂度为O(n)。


	4>>快速排序
	思想：
	通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。
	示例：
	初始关键字 	 ［49   38   65   97   76   13  27   49］
	一趟排序之后 ［27   38   13］ 49 ［76   97  65   49］ 
	二趟排序之后 ［13］ 27 ［38］ 49 ［49   65］ 76 ［97］
	三趟排序之后   13   27   38   49   49 ［65］ 76   97
	最后的排序结果 13   27   38   49   49   65   76   97
	时间复杂度：
	快速排序主体算法时间运算量约 O(log2n),划分子区函数运算量约 O(n),所以总的时间复杂度为 O(nlog2n),它显然优于冒泡排序 O(n2).
	可是算法的优势并不是绝对的。
	试分析，当原文件关键字有序时,快速排序时间复杂度是 O(n2), 这种情况下快速排序不快。
	而这种情况的冒泡排序是 O(n), 反而很快。
	在原文件记录关键字无序时的多种排序方法中，快速排序被认为是最好的一种排序方法。
	*
	*/
	public function sort_type($arr,$sort_type){//集成4个，通过type甄别
		switch ($sort_type) {
			case 'insert'://插入排序算法
			    foreach($arr as $key=>$value){
			        $tmp = $arr[$key];
			        $j = $key - 1;
			        while($arr[$j] > $tmp){
			            $arr[$j+1] = $arr[$j];
			            $arr[$j] = $tmp;
			            $j--;
			         }
			     } 
				break;
			case 'select'://选择排序算法
			    	for($i=0, $len=count($arr); $i<$len-1; $i++) {
			        	$p = $i;
			        	for($j=$i+1; $j<$len; $j++) {
			            	if($arr[$p] > $arr[$j]) {
			                	$p = $j;
			            	}
			        	}
				        if($p != $i) {
				            $tmp = $arr[$p];
				            $arr[$p] = $arr[$i];
				            $arr[$i] = $tmp;
				        }
			    	}
				break;
			case 'bubble'://冒泡排序算法
			$count = count($arr);     
			    if ($count <= 0) return false;     
			    for($i=0; $i<$count; $i++){     
			        for($j=$count-1; $j>$i; $j--){     
			            if ($arr[$j] < $arr[$j-1]){     
			                $tmp = $arr[$j];     
			                $arr[$j] = $arr[$j-1];     
			                $arr[$j-1] = $tmp;     
			             }     
			         }     
			     }     
     			break;
     		case 'quick'://快速排序算法
     			if(count($arr)<=1)return $arr;
				$key=$arr[0];
				$left_arr=array();
				$right_arr=array();
				for($i=1;$i<count($arr);$i++){
					if($arr[$i]<=$key){
					    $left_arr[]=$arr[$i];  
					}else{
						$right_arr[]=$arr[$i];  
					}
				}
				$left_arr = $this->sort_type($left_arr,'quick');     
				$right_arr = $this->sort_type($right_arr,'quick');      
				return array_merge($left_arr, array($key), $right_arr);     
     			break;
		}
		return $arr;
	}
	//单独的插入排序算法
	function insert_sort($arr) {
	    //区分 哪部分是已经排序好的
	    //哪部分是没有排序的
	    //找到其中一个需要排序的元素
	    //这个元素 就是从第二个元素开始，到最后一个元素都是这个需要排序的元素
	    //利用循环就可以标志出来
	    //i循环控制 每次需要插入的元素，一旦需要插入的元素控制好了，
	    //间接已经将数组分成了2部分，下标小于当前的（左边的），是排序好的序列
	    for($i=1, $len=count($arr); $i<$len; $i++) {
	        //获得当前需要比较的元素值。
	        $tmp = $arr[$i];
	        //内层循环控制 比较 并 插入
	        for($j=$i-1;$j>=0;$j--) {
	   	//$arr[$i];//需要插入的元素; $arr[$j];//需要比较的元素
	            if($tmp < $arr[$j]) {
	                //发现插入的元素要小，交换位置
	                //将后边的元素与前面的元素互换
	                $arr[$j+1] = $arr[$j];
	                //将前面的数设置为 当前需要交换的数
	                $arr[$j] = $tmp;
	            } else {
	                //如果碰到不需要移动的元素
	           //由于是已经排序好是数组，则前面的就不需要再次比较了。
	                break;
	            }
	        }
	    }
	    //将这个元素 插入到已经排序好的序列内。
	    //返回
	    return $arr;
	}
	//选择排序（一维数组）     
	function select_sort($arr) {
		//实现思路 双重循环完成，外层控制轮数，当前的最小值。内层 控制的比较次数
    	//$i 当前最小值的位置， 需要参与比较的元素
    	for($i=0, $len=count($arr); $i<$len-1; $i++) {
        //先假设最小的值的位置
        	$p = $i;
        //$j 当前都需要和哪些元素比较，$i 后边的。
        	for($j=$i+1; $j<$len; $j++) {
            //$arr[$p] 是 当前已知的最小值
            	if($arr[$p] > $arr[$j]) {
     		//比较，发现更小的,记录下最小值的位置；并且在下次比较时，
 			// 应该采用已知的最小值进行比较。
                	$p = $j;
            	}
        	}
        	//已经确定了当前的最小值的位置，保存到$p中。
 		//如果发现 最小值的位置与当前假设的位置$i不同，则位置互换即可
	        if($p != $i) {
	            $tmp = $arr[$p];
	            $arr[$p] = $arr[$i];
	            $arr[$i] = $tmp;
	        }
    	}
    //返回最终结果
    return $arr;
	}
	//冒泡排序（一维数组）
	function getpao($arr)
	{  
	  $len=count($arr);
	  //设置一个空数组 用来接收冒出来的泡
	  //该层循环控制 需要冒泡的轮数
	  for($i=1;$i<$len;$i++)
	  { //该层循环用来控制每轮 冒出一个数 需要比较的次数
	    for($k=0;$k<$len-$i;$k++)
	    {
	       if($arr[$k]>$arr[$k+1])
	        {
	            $tmp=$arr[$k+1];
	            $arr[$k+1]=$arr[$k];
	            $arr[$k]=$tmp;
	        }
	    }
	  }
	  return $arr;
	} 
	//单独的快速排序算法
	function quick_sort($arr) {
	    //先判断是否需要继续进行
	    $length = count($arr);
	    if($length <= 1) {
	        return $arr;
	    }
	    //如果没有返回，说明数组内的元素个数 多余1个，需要排序
	    //选择一个标尺
	    //选择第一个元素
	    $base_num = $arr[0];
	    //遍历 除了标尺外的所有元素，按照大小关系放入两个数组内
	    //初始化两个数组
	    $left_array = array();//小于标尺的
	    $right_array = array();//大于标尺的
	    for($i=1; $i<$length; $i++) {
	        if($base_num > $arr[$i]) {
	            //放入左边数组
	            $left_array[] = $arr[$i];
	        } else {
	            //放入右边
	            $right_array[] = $arr[$i];
	        }
	    }
	    //再分别对 左边 和 右边的数组进行相同的排序处理方式
	    //递归调用这个函数,并记录结果
	    $left_array = quick_sort($left_array);
	    $right_array = quick_sort($right_array);
	    //合并左边 标尺 右边
	    return array_merge($left_array, array($base_num), $right_array);
	}
}
// $a=new sort();
// $b=$a->select_sort(array(44,22,77,55,88));
// var_dump($b);